"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,a,i){void 0===i&&(i=a),Object.defineProperty(e,i,{enumerable:!0,get:function(){return t[a]}})}:function(e,t,a,i){void 0===i&&(i=a),e[i]=t[a]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var a in e)"default"!==a&&Object.hasOwnProperty.call(e,a)&&__createBinding(t,e,a);return __setModuleDefault(t,e),t};Object.defineProperty(exports,"__esModule",{value:!0}),exports.getNextGameStates=exports.isGameOver=exports.updateGameState=exports.isValidMove=exports.getStartGameState=exports.isGameState=void 0;const obray_1=require("../../lib/obray"),types_1=require("../types"),limits_1=require("./limits"),Pawn=__importStar(require("./pawn")),player_1=require("./player"),position_1=require("./position");function isGameState(e){return obray_1.hasKey(e,"limits",limits_1.isLimits)&&obray_1.hasKey(e,"pawns")&&obray_1.isArray(e.pawns,Pawn.isPawn)&&obray_1.hasKey(e,"player",player_1.isPlayer)&&noPawnsOutsideOfLimits(e)&&noPawnsOnSameField(e)&&player_1.isPlayerAlive(e.player,e.pawns)}function getStartGameState(e){let t=[];if(e[0]&&(t=t.concat(Pawn.getStartPawns(types_1.EPlayer.RED))),e[1]&&(t=t.concat(Pawn.getStartPawns(types_1.EPlayer.GREEN))),e[2]&&(t=t.concat(Pawn.getStartPawns(types_1.EPlayer.YELLOW))),e[3]&&(t=t.concat(Pawn.getStartPawns(types_1.EPlayer.BLUE))),t.length<1)return{pawns:t,limits:limits_1.getStartLimits(),player:types_1.EPlayer.RED};return{pawns:t,limits:limits_1.calcLimits(t,limits_1.getStartLimits()),player:player_1.getNextPlayer(types_1.EPlayer.GREEN,t)}}function isValidMove(e,t,a){var i;return!isGameOver(e)&&(null===(i=e.pawns[t])||void 0===i?void 0:i.player)===e.player&&position_1.isInPositions(a,Pawn.getMoves(t,e.pawns,e.limits))}function updateGameState(e,t,a){const i=Pawn.getPawnsIAtPosition(e.pawns,a);let r=obray_1.deepClone(e.pawns);r[t].position=a,i>=0&&r.splice(i,1);const s=limits_1.calcLimits(r,e.limits),n=Pawn.getIndexOfPawnInDeadlock(r,s);return-1===n||isGameOver({limits:s,pawns:r,player:e.player})||r.splice(n,1),{limits:s,pawns:r,player:player_1.getNextPlayer(e.player,r)}}function isGameOver(e){var t;const a=null===(t=e.pawns[0])||void 0===t?void 0:t.player;for(let t=1,i=e.pawns.length;t<i;t++)if(a!==e.pawns[t].player)return!1;return!0}function getNextGameStates(e){let t=[];for(let a=0,i=e.pawns.length;a<i;a++){if(e.pawns[a].player!==e.player)continue;const i=Pawn.getMoves(a,e.pawns,e.limits).map(t=>updateGameState(e,a,t));t=t.concat(i)}return t}function noPawnsOutsideOfLimits({pawns:e,limits:t}){for(let a=0,i=e.length;a<i;a++)if(!limits_1.isWithinLimits(e[a].position,t))return!1;return!0}function noPawnsOnSameField({pawns:e}){let t=e.map(e=>e.position);t.sort(position_1.sortPositions);for(let e=1,a=t.length;e<a;e++)if(position_1.isSamePosition(t[e-1],t[e]))return!1;return!0}exports.isGameState=isGameState,exports.getStartGameState=getStartGameState,exports.isValidMove=isValidMove,exports.updateGameState=updateGameState,exports.isGameOver=isGameOver,exports.getNextGameStates=getNextGameStates;